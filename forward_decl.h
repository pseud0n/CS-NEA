#ifndef FORWARD_DECL_H_
#define FORWARD_DECL_H_

#define OPTR UL::ObjectPointer

namespace UL {
    enum class Types {
        null=0,
		number,
		/*
		 * The default number type stores an int
		 * TODO Make it store big float
		 * Each integer or float literal is converted to this type
		 */
		string,
		/*
         * Stores a sequence of (wide) characters
		 * The value is not constant and all operations are in-place
		 */
		cpp_function,
		/*
		 * Does not have an associated union type
		 * While it has a 'call' method, it is also directly callable
		 * (otherwise there would be infinite recursion)
		 * It doesn't need to know argument type but it needs to know number of arguments
		 * Takes a list of argument names and an optional name to store all extra arguments in list form
		 * TODO Add keyword arguments (not separate syntax)
		 *
		 * There are 2 types of functions, depending on the context
		 * Functions that you write in Unnamed Language
		 	 * They take an array of Object
		 	 * The code within is generated by the UL interpreter
		 	 * They are less efficient since the interpreter doesn't know what you'll do with the variables
		 	 * Likely less human-readable
		 * Functions that I write in C++
		 	 * They take an array of WrappedUnionObject
				 * This type is a non-reference-counted version of the standard Object
				 * It acts as an intermediate object between the types that its union can store and an Object
				 * It can be efficiently converted to any type that it stores
				 * It can also be converted to an Object by adding a Location object and classifying it as weak or strong
			 * They are more efficient since you can interpret arguments as a variety of other types for efficiency
			 * Function returns an Object
		 */
        bytecode_function,

		list,
		/*
		 * This type means that the object's union value is an array
		 * To be converted to another type, each object must be convertible to the same type
		 * If the types within a list are not all the same or convertible to a common type, use 'o' as type
		 */

         user_defined_object
	};

    struct Object;

    enum class Types;
    struct ByteCodeFunction;
    struct CppFunction;

    struct UserDefinedObject;

    union ObjectUnion {
        std::string *string_val; //std::string pointer
        double *numerical_val; //pointer to double
        CppFunction *function_val; //pointer to a C++ function
        ByteCodeFunction *bytecode_val; //pointer to a bytecode function, which stores a start val & number of lines
        std::vector<Object> *list_val; //pointer to a vector of objects
        UserDefinedObject *udo_val;
    };

    struct Object {
        /*
        The Object is the standard class which allows several different types to be contained in on type
        An Object can be used in 2 ways: on the heap or on the stack.
        A heap Object should only be created as part of an ObjectPointer/OPTR to get reference counted
        A stack Object should not be wrapped by an OPTR since it will get deallocated anyway
        Note that a wrapped Object will be explicitly deleted (which UB if allocated on the stack)

        The strength of a stack Object is ignored since it won't be reference-counted
        The strength of a heap Object is important and is tracked by an OPTR
        This is why a heap Object must be wrapped by and OPTR, which automatically deletes the object
        A stack Object still has a reference count, but it is unused
        */
        friend const char* r_optr_constness(const OPTR&);

        ObjectUnion union_val;
        Types type;
        bool is_const;
        /*
        References to this object will all be weak and ownership may not be transferred.
        A const object is used when the object is part of something built-in.
        For example, member functions of built-in types would not be reference counted.
        It would be pointless to keep track of references because we know that at least one reference will always remain
        The original OPTR is a strong reference but all subsequent references are weak references
        
        */
        //bool is_weak;
        //Location *reference_location;
        unsigned int reference_count;
        Object(std::nullptr_t, bool=false);
        Object(double, bool=false);
        Object(int, bool=false);
        Object(const char*, bool=false);
        Object(CppFunction*, bool=false);
        Object(ByteCodeFunction*, bool=false);
        Object(UserDefinedObject*, bool=false);
        template <typename T> Object(std::initializer_list<T>, bool=false);
        template <typename ... T> Object(std::tuple<T...>, bool=false);
        Object(const Object*, bool=false);
        //Object* make_reference();
        ~Object();
        void operator ++();
        void operator --();
        operator int() const;
        operator std::string () const;
        OPTR operator ()(std::vector<OPTR>);
        //operator double();
        Object operator *(const Object&);
    };

    struct UserDefinedObject {
        std::unordered_map<std::string, OPTR> attributes;
        //template <typename... KeyValuePairT> UserDefinedObject(KeyValuePairT...);
        UserDefinedObject(std::unordered_map<std::string, OPTR>);
        OPTR get_attribute(std::string) const;
        template <typename AlternateReturnT> AlternateReturnT get_attribute(std::string name, AlternateReturnT alternate_value) const;
        //std::string get_attribute(std::string name, std::string alternate_value);
        bool has_attribute(std::string name) const;
        void delete_attribute(std::string name);
    };
}

//std::ostream& operator <<(std::ostream& stream, const UL::Object& object);
//std::ostream& operator <<(std::ostream&, const UL::Types);

#endif
