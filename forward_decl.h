#ifndef FORWARD_DECL_H_
#define FORWARD_DECL_H_

#define OPTR UL::ObjectPointer

namespace UL {
    enum class Types {
        null=0,
		number,
		/*
		 * The default number type stores an int
		 * TODO Make it store big float
		 * Each integer or float literal is converted to this type
		 */
		string,
		/*
         * Stores a sequence of (wide) characters
		 * The value is not constant and all operations are in-place
		 */
		cpp_function,
		/*
		 * Does not have an associated union type
		 * While it has a 'call' method, it is also directly callable
		 * (otherwise there would be infinite recursion)
		 * It doesn't need to know argument type but it needs to know number of arguments
		 * Takes a list of argument names and an optional name to store all extra arguments in list form
		 * TODO Add keyword arguments (not separate syntax)
		 *
		 * There are 2 types of functions, depending on the context
		 * Functions that you write in Unnamed Language
		 	 * They take an array of Object
		 	 * The code within is generated by the UL interpreter
		 	 * They are less efficient since the interpreter doesn't know what you'll do with the variables
		 	 * Likely less human-readable
		 * Functions that I write in C++
		 	 * They take an array of WrappedUnionObject
				 * This type is a non-reference-counted version of the standard Object
				 * It acts as an intermediate object between the types that its union can store and an Object
				 * It can be efficiently converted to any type that it stores
				 * It can also be converted to an Object by adding a Location object and classifying it as weak or strong
			 * They are more efficient since you can interpret arguments as a variety of other types for efficiency
			 * Function returns an Object
		 */
        bytecode_function,

		list,
		/*
		 * This type means that the object's union value is an array
		 * To be converted to another type, each object must be convertible to the same type
		 * If the types within a list are not all the same or convertible to a common type, use 'o' as type
		 */

         user_defined_object
	};

    struct Object;

    enum class Types;
    struct ByteCodeFunction;
    struct CppFunction;
    struct Location;
    class ObjectPointer;

    struct UserDefinedObject;

    union ObjectUnion {
        std::string *string_val; //std::string pointer
        double *numerical_val; //pointer to double
        CppFunction *function_val; //pointer to a C++ function
        ByteCodeFunction *bytecode_val; //pointer to a bytecode function, which stores a start val & number of lines
        std::vector<Object> *list_val; //pointer to a vector of objects
        UserDefinedObject *udo_val;
    };

    struct Object {
        /*
        The Object is the standard class which allows several different types to be contained in on type
        An Object can be used in 2 ways: on the heap or on the stack.
        A heap Object should only be created as part of an ObjectPointer/OPTR to get reference counted
        A stack Object should not be wrapped by an OPTR since it will get deallocated anyway
        The strength of a stack Object is ignored since it won't be reference-counted
        The strength of a heap Object is important and is tracked by an OPTR
        This is why a heap Object must be wrapped by and OPTR, which automatically deletes the object
        A stack Object still has a reference count, but it is unused
        */
        ObjectUnion union_val;
        Types type;
        //bool is_weak;
        //Location *reference_location;
        unsigned int reference_count;
        Object(std::nullptr_t /*, bool=false*/);
        Object(double /*, bool=false*/);
        Object(int);
        Object(const char* /*, bool=false*/);
        Object(CppFunction* /*, bool=false*/);
        Object(ByteCodeFunction* /*, bool=false*/);
        Object(UserDefinedObject* /*, bool=false*/);
        template <typename T> Object(std::initializer_list<T> /*, bool=false*/);
        template <typename ... T> Object(std::tuple<T...> /*, bool=false*/);
        Object(const Object* /*, bool=false*/);
        //Object* make_reference();
        ~Object();
        operator int() const;
        operator std::string () const;
        OPTR operator ()(std::vector<OPTR>);
        //operator double();
        Object operator *(const Object&);
    };

    class ObjectPointer { // Should be used instead of object pointers
    private:
        // This type should be predominantly used on the stack
        Object* object_ptr; // The associated object

    public:
        bool is_weak;

        ObjectPointer()
        	: object_ptr(0), is_weak(false) {
        	// Invalid object - do not use!
        }

        ObjectPointer(Object* object_ptr, bool is_weak=false)
            : object_ptr(object_ptr), is_weak(is_weak) {
            cout << "Created ObjectPointer " << this << "\n";
        }

        template <typename ConstructorT>
        ObjectPointer(ConstructorT construct_from, bool is_weak=false)
			: is_weak(is_weak) {
            object_ptr = new Object(construct_from);
        }

        ~ObjectPointer() {
            if (!is_weak) --object_ptr->reference_count;
        }

        ObjectPointer(const ObjectPointer& from, bool force_strong=false)
            : object_ptr(from.object_ptr), is_weak(!force_strong && from.is_weak) {
            if (!is_weak) ++object_ptr->reference_count;
        }

        template <typename ConstructFromT>
        void create_from_blank(ConstructFromT construct_from, bool is_weak=false) {
        	object_ptr = new Object(construct_from);
			this->is_weak = is_weak;
        }

        template <typename CastT>
        CastT cast() const {
            return static_cast<CastT>(*object_ptr);
        }
    };

    struct UserDefinedObject {
        std::unordered_map<std::string, OPTR> attributes;
        template <typename ... KeyValuePairT> UserDefinedObject(KeyValuePairT...);
        OPTR get_attribute(std::string) const;
        template <typename AlternateReturnT> AlternateReturnT get_attribute(std::string name, AlternateReturnT alternate_value) const;
        //std::string get_attribute(std::string name, std::string alternate_value);
        bool has_attribute(std::string name) const;
        void delete_attribute(std::string name);
    };
}

//std::ostream& operator <<(std::ostream& stream, const UL::Object& object);
//std::ostream& operator <<(std::ostream&, const UL::Types);

#endif
