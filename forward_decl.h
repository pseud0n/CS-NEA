#ifndef FORWARD_DECL_H
#define FORWARD_DECL_H
//INCLUDED(FORWARD_DECL)
//Included("forward_decl");

//#define OPTR UL::ObjectPointer


class NullType {};

enum class Types {
    null_type,
    /*
    The equivalent of NULL/None/whatever.
    This type is returned by default from functions
    */
	number,
	/*
	The default number type stores an int
	TODO Make it store big float
	Each integer or float literal is converted to this type
	*/
	string,
	/*
    Stores a sequence of (wide) characters
	The value is not constant and all operations are in-place
	 */
	boolean,
	
	cpp_function,
	/*
	Does not have an associated union type
	While it has a 'call' method, it is also directly callable
	(otherwise there would be infinite recursion)
	It doesn't need to know argument type but it needs to know number of arguments
	Takes a list of argument names and an optional name to store all extra arguments in list form
	TODO Add keyword arguments (not separate syntax)
	There are 2 types of functions, depending on the context
	Functions that you write in Unnamed Language
	 	They take an array of Object
	 	The code within is generated by the UL interpreter
	 	They are less efficient since the interpreter doesn't know what you'll do with the variables
	 	Likely less human-readable
	Functions that I write in C++
	 	They take an array of WrappedUnionObject
			This type is a non-reference-counted version of the standard Object
			It acts as an intermediate object between the types that its union can store and an Object
			It can be efficiently converted to any type that it stores
			It can also be converted to an Object by adding a Location object and classifying it as weak or strong
		They are more efficient since you can interpret arguments as a variety of other types for efficiency
		Function returns an Object
	*/
	cpp_function_view,

    bytecode_function,

	pair,
	/*
	Stores 2 objects - a key and value
	*/

	array,
	/*
	This type means that the object's union value is an array
    An array cannot be modified (although its value is not known a compile time)
    A vector has fast random access since it is stored contiguously
	*/

    list,
    /*
    Implemented as a doubly-linked list for iteration in both directions.
    Does not support fast random access but supports fast bidirectional iteration
    Iterating by incrementing a variable and indexing is not recommended
    */

    dictionary,
    /*
    Uses key-value pairs and hashes the keys
    Keys must be hashable types (all immutable types are hashable)
	Is constructed from a list or array of pairs
    */

	class_object,
	/*
	Can be instantiated to an object which can be instantiated
	*/

	base_exception,
	/*
	Causes deletion of all scopes until catch
	*/
    
    custom,

	code_block,

	if_chain,

	generic_singleton,

	any
};

class Object;
struct ByteCodeFunction;
class CppFunction;
struct UserDefinedObject;
class Pair;
struct ExternalObject;
class FunctionView;
class BaseException;
class CodeBlock;
class If;
class Singleton;

namespace Aliases {
	using BlankT 				= char;
	using NullT 				= std::nullptr_t;
	using NumT 					= bmp::cpp_int;
	using BoolT 				= bool;
	using StringT 				= std::string;
	using CppFunctionT 			= CppFunction;
	using CppFunctionViewT		= FunctionView;
	using ByteCodeFunctionT 	= ByteCodeFunction;
	using PairT 				= std::pair<ExternalObject, ExternalObject>;
	using ArrayT 				= HashableArray<ExternalObject>;
	using ListT 				= std::list<ExternalObject>;
	using DictT 				= std::unordered_map<ExternalObject, ExternalObject>;
	using BaseExceptionT		= BaseException;
	using CustomT	 			= std::unordered_map<std::string, ExternalObject>;
	using CodeBlockT			= CodeBlock;
	using IfT					= If;
	using GenericSingletonT		= Singleton;
	// Intended to reduce the effort required to change 
}

#endif
