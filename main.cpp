#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <functional>
#include <cstring>
#include <unordered_set>
#include <sstream>
#include <array>
#include <cassert>

#include "ForwardDecl.h" //Header file to forward-declare object

using std::cout;

#define OBJ_RET(x) [](){ return x; }
//If an object is optional, no need to construct it unless it is actuall used
//Assumes that return type of lambda is a UL::Object, so this will be converted
 
#define DY_LMBD [](UL::CppFunction& argument_data, std::vector<UL::Object> arguments)
//Macro for defnining the lambda for a CppFunction as DY_LMBD{ /* stuff */ }

namespace UL {

    struct ByteCodeFunction;
    struct CppFunction;

    enum class Builtins {
		number=0,
		/*
		 * The default number type stores an int
		 * TODO Make it store big float
		 * Each integer or float literal is converted to this type
		 */
		string,
		/*
         * Stores a sequence of (wide) characters
		 * The value is not constant and all operations are in-place
		 */
		cpp_function,
		/*
		 * Does not have an associated union type
		 * While it has a 'call' method, it is also directly callable
		 * (otherwise there would be infinite recursion)
		 * It doesn't need to know argument type but it needs to know number of arguments
		 * Takes a list of argument names and an optional name to store all extra arguments in list form
		 * TODO Add keyword arguments (not separate syntax)
		 *
		 * There are 2 types of functions, depending on the context
		 * Functions that you write in Unnamed Language
		 	 * They take an array of Object
		 	 * The code within is generated by the UL interpreter
		 	 * They are less efficient since the interpreter doesn't know what you'll do with the variables
		 	 * Likely less human-readable
		 * Functions that I write in C++
		 	 * They take an array of WrappedUnionObject
				 * This type is a non-reference-counted version of the standard Object
				 * It acts as an intermediate object between the types that its union can store and an Object
				 * It can be efficiently converted to any type that it stores
				 * It can also be converted to an Object by adding a Location object and classifying it as weak or strong
			 * They are more efficient since you can interpret arguments as a variety of other types for efficiency
			 * Function returns an Object
		 */
        bytecode_function,

		list
		/*
		 * This type means that the object's union value is an array
		 * To be converted to another type, each object must be convertible to the same type
		 * If the types within a list are not all the same or convertible to a common type, use 'o' as type
		 */
	};

    struct ByteCodeFunction {
        //Functor class which represents a function written in bytecode
        size_t start_line, code_length;
    };

    struct CppFunction {
        //Functor class which represents a function written in C++
        size_t min_arg_count; //Minimum possible arguments required to be entered
        const std::vector<std::function<Object()> > optional_arguments;
        //Vector of lambdas returning UL::Object (implicitly converts return value) to stop objects from being constructed if they're not actually used
        //All additional arguments go to default values and then to the variable storing variadic arguments
        bool is_variadic; //Whether the function accepts any number of arguments beyond required + optional
        std::function<Object(CppFunction&, std::vector<Object>)> function; //The function object containing the code

        template <typename ... T>
        static bool assign_args(std::tuple<T* ...> outputs, std::vector<Object> inputs) {
            //Iterating and using std::get<i> is not possible since template value must be a compile-time constant not a variable (rvalue not lvalue)
            //E.g. `std::get<i>(outputs) = inputs[i]` is not allowed
            //This is because the return type must be known at compile-time
            size_t i = 0; //Keep track of current index (for inputs)
            std::apply( //Since C++17
                [&inputs, &i] //Capture 2 variables by reference to lambda
                ( 
                    auto&&... var_pointer //rvalue reference to the current pointer
                ) {
                    ((*var_pointer = inputs[i++]), ...);  //Set variable value of pointer to the corresponding input value and increment
                    //(C++17: fold expresson)
                }, outputs //The tuple to iterate through
            );
            return true;
        }
        //E.g.: int a; char *b; CppFunction::assign_args<int, char*>(std::make_tuple(&a, &b), {10, "cloverfield lane"});

        CppFunction(size_t min_arg_count, std::vector<std::function<Object()> > optional_arguments, bool is_variadic, std::function<Object(CppFunction&, std::vector<UL::Object>)> func)
            : min_arg_count(min_arg_count), optional_arguments(optional_arguments), is_variadic(is_variadic) {
            function = func;
        }

        CppFunction(const CppFunction& from) //Copy constructor
            : min_arg_count(from.min_arg_count), optional_arguments(from.optional_arguments), is_variadic(from.is_variadic) {
        }
    };

    struct Location {
		unsigned int reference_count;
		static std::unordered_set<Location*> instances;
        std::unordered_set<Object*> bound_objects; //All strongly or weakly-referenced heap pointers bound to the Location object

		Location()
			: reference_count(0) {
			cout << "NEWREF0 " << this << "\n";
			instances.insert(this);
		}

        Location(Object* first_heap_pointer)
            : reference_count(!first_heap_pointer->is_weak) { //false -> 1, true -> 0 (convenient, right?)
            cout << "NEWREF1 (" << (first_heap_pointer->is_weak ? "weak" : "strong") <<  ") "<< this << " (object @ " << first_heap_pointer <<  ")\n";
            bound_objects.insert(first_heap_pointer);
            instances.insert(this);
        }

		~Location() {
			cout << "DELREF " << this << " (remaining weakrefs: "  << bound_objects.size() << ")\n";
            for (auto it : bound_objects) delete it;
            //Dereference iterator and delete resulting heap Object pointer
			instances.erase(this); //Remove empty Location from set of Location instances
		}

		void operator +=(Object* heap_pointer) {
			if (!heap_pointer->is_weak) std::cout << "INCREF " << this << " to " << ++reference_count <<"\n";
            bound_objects.insert(heap_pointer);
		}

		void operator -=(Object* heap_pointer) {
            if (reference_count == 0)
                delete this; //Was decremented without giving it any initial values; immediately delete self
                //Note: This shouldn't happen!
            else {
                bound_objects.erase(heap_pointer); //Remove strong/weak reference
                if (!heap_pointer->is_weak) std::cout << "DECREF " << this << " to " << reference_count <<"\n";
                if (reference_count == 0) //If no strong references remaining
                    delete this; //Can I do this (calls destructor)?
            }
		}

		static std::string show_instances() {
			std::stringstream stream;
			stream << "{";
			for (auto it = instances.begin(); it != instances.end(); ++it) {
				if (it != instances.begin()) stream << ", ";
				stream << *it << ":" << (**it).reference_count;
			}
			stream << "}";
			return stream.str();
		}
	};

    auto Location::instances = std::unordered_set<Location*>(); //Construct set of locations

    Object::Object(double x, bool is_weak) //default argument
        : type(Builtins::number), is_weak(is_weak), reference_location(new Location(this)) {
        union_val.numerical_val = new double(x);
    }

    Object::Object(const char* string, bool is_weak) //Enter a string literal
        : type(Builtins::string), is_weak(is_weak), reference_location(new Location(this)) {
        union_val.string_val = new std::string(string);
    }

    Object::Object(CppFunction* cpp_function, bool is_weak) //Enter a CppFunction heap pointer
        : type(Builtins::cpp_function), is_weak(is_weak), reference_location(new Location(this)) {
        union_val.function_val = cpp_function; //cpp_function should be a heap pointer
    }

    Object::Object(ByteCodeFunction* bc_function, bool is_weak)
        : type(Builtins::bytecode_function), is_weak(is_weak), reference_location(new Location(this)) {
        union_val.bytecode_val = bc_function;
    }

    Object::Object(const Object* from, bool force_weak)
        : type(from->type), is_weak(force_weak || from->is_weak), reference_location(from->reference_location) {
        cout << "COPY (" << (from->is_weak ? "weak->" : "strong->") << (is_weak ? "weak) " : "strong) ") << from << " to " << this << "\n";
        *reference_location += this;
        switch (type) {
            case Builtins::number:
                union_val.numerical_val = new double(*from->union_val.numerical_val);
                break;
            case Builtins::string:
                *union_val.string_val = *from->union_val.string_val;
                break;
            case Builtins::cpp_function:
                union_val.function_val = new CppFunction(*from->union_val.function_val);
                break;
            case Builtins::bytecode_function:
                *union_val.bytecode_val = *from->union_val.bytecode_val;
                break;
            case Builtins::list:
                *union_val.list_val = *from->union_val.list_val;
                break;
            default:
                cout << "How did I get here?\n";
        }
    }

    Object::~Object() {
        cout << "Deleting object '" << *this << "' (" << this << ")\n";
        *reference_location -= this; //Overloaded dereference on UL::Location object on heap
        switch (type) {
            case Builtins::number:
                delete union_val.numerical_val;
                break;
            case Builtins::string:
                delete union_val.string_val;
                break;
            case Builtins::cpp_function:
                delete union_val.function_val;
                break;
            case Builtins::bytecode_function:
                delete union_val.bytecode_val;
                break;
            case Builtins::list:
                delete union_val.list_val;
                break;
        }
    }

    /*
    struct Object {
        ObjectUnion union_val;
        //Memory which can be replaced with any type in ObjectUnion definition
        Builtins type;
        bool is_weak;
        Location *reference_location;

        Object(double x, bool is_weak=false) //Enter a double literal
            : type(Builtins::number), is_weak(is_weak), reference_location(new Location) {
            union_val.numerical_val = new double(x);
        }

        Object (const char* string, bool is_weak=false) //Enter a string literal
            : type(Builtins::string), is_weak(is_weak), reference_location(new Location) {
            union_val.string_val = new std::string(string);
        }

        Object(CppFunction* cpp_function, bool is_weak=false) //Enter a CppFunction heap pointer
            : type(Builtins::cpp_function), is_weak(is_weak), reference_location(new Location) {
            union_val.function_val = cpp_function; //cpp_function should be a heap pointer
        }

        Object(ByteCodeFunction* bc_function, bool is_weak = false)
            : type(Builtins::bytecode_function), is_weak(is_weak), reference_location(new Location) {
            union_val.bytecode_val = bc_function;
        }

        
        Object(std::vector<Object>* values, bool is_weak = false)
            : type(Builtins::list), is_weak(is_weak), reference_location(new Location) {
            union_val.list_val = values;
        }

        Object(std::vector<Object> values, bool is_weak = false)
            : type(Builtins::list), is_weak(is_weak), reference_location(new Location) {
            union_val.list_val = new std::vector<Object>(values);
        }

        Object(const Object& from, bool force_weak = false)
            : type(from.type), is_weak(force_weak || from.is_weak), reference_location(from.reference_location) {
            cout << "Copied " << this << "\n";
            if (!is_weak) *reference_location += this;
            switch (type) {
                case Builtins::number:
                    *union_val.numerical_val = *from.union_val.numerical_val;
                    break;
                case Builtins::string:
                    *union_val.string_val = *from.union_val.string_val;
                    break;
                case Builtins::cpp_function:
                    *union_val.function_val = *from.union_val.function_val;
                    break;
                case Builtins::bytecode_function:
                    *union_val.bytecode_val = *from.union_val.bytecode_val;
                    break;
                case Builtins::list:
                    *union_val.list_val = *from.union_val.list_val;
                    break;
            }
        }

        ~Object() {
            if (!is_weak) --*reference_location; //Overloaded dereference on UL::Location object on heap
            switch (type) {
                case Builtins::number:
                    delete union_val.numerical_val;
                    break;
                case Builtins::string:
                    delete union_val.string_val;
                    break;
                case Builtins::cpp_function:
                    delete union_val.function_val;
                    break;
                case Builtins::bytecode_function:
                    delete union_val.bytecode_val;
                    break;
                case Builtins::list:
                    delete union_val.list_val;
                    break;
            }
        }

        Object operator *(const Object& arg2) {
            Object result(*this, true);
            switch(arg2.type) {
                case Builtins::number:
                    *result.union_val.numerical_val *= *arg2.union_val.numerical_val;
                    result.strengthen();
                    break;
            }
        }

        void strengthen() {
            assert(is_weak);
            reference_location = new Location;
            is_weak = false;
        }
    };
    */

}

std::ostream& operator <<(std::ostream& stream, UL::Object& object) {
    switch (object.type) {
        case UL::Builtins::number:
            return stream << *object.union_val.numerical_val;
        case UL::Builtins::string:
            return stream << "\"" <<*object.union_val.string_val << "\"";
        case UL::Builtins::cpp_function:
            return stream << "<Cpp Function " << &object << ">";
            break;
        case UL::Builtins::bytecode_function:
            return stream << "<BC Function " << &object << ">";
            break;
        case UL::Builtins::list:
            std::stringstream sstream;
            sstream << "{";
            for (auto it = object.union_val.list_val->begin(); it != object.union_val.list_val->end(); ++it) {
                if (it != object.union_val.list_val->begin()) sstream << ", ";
                sstream << *it; //Recursion!
            }
            sstream << "}";
            return stream << sstream.str();
            break;
    }
}

int main() {
    cout << __cplusplus << "\n";
    /*
    UL::Object func(new UL::CppFunction(3, {OBJ_RET(10), OBJ_RET(11)}, true, DY_LMBD {
        return UL::Object(99);
    }));
    */

    #include "Tests/SimpleWeakRef.h"

    return 0;
}