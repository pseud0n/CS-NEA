
/*
 *  __cplusplus 201703
 * Created by Alex Scorza
 * Written for MinGW GCC, g++ version 9.2.0, 64-bit
 * Hello, world!
 */

#include <iostream> //cout
#include <unordered_map> //unordered_map
#include <vector> //vector
#include <string> //string
#include <functional> //function
#include <cstring> //(string.h) strcpy, strcmp
#include <stdexcept>
#include <set> //set
#include <sstream> //stringstream
#include <array> //array

#define SEP std::cout << "--------------\n"
#define DY_FN [](std::vector<Object&> args)
#define UL_RET(x) [](){return x;} //Implicitly converts to return type UL::Object
#define UL_LMBD [](std::vector<UL::Intermediary&> arguments_input, UL::Arguments& arguments_data)

namespace UL {
	struct Object;
	struct Arguments;
	struct Intermediary;
	struct Function;

	enum class Builtins {
		number=0,
		/*
		The default number type stores an int
		TODO Make it store big float
		Each integer or float literal is converted to this type
		 */
		string,
		/*
		Stores a sequence of (wide) characters
		The value is not constant and all operations are in-place
		 */
		function,
		/*
		 * Does not have an associated union type
		 * While it has a 'call' method, it is also directly callable
		 * (otherwise there would be infinite recursion)
		 * It doesn't need to know argument type but it needs to know number of arguments
		 * Takes a list of argument names and an optional name to store all extra arguments in list form
		 * TODO Add keyword arguments (not separate syntax)
		 *
		 * There are 2 types of functions, depending on the context
		 * Functions that you write in Unnamed Language
		 	 * They take an array of Object
		 	 * The code within is generated by the UL interpreter
		 	 * They are less efficient since the interpreter doesn't know what you'll do with the variables
		 	 * Likely less human-readable
		 * Functions that I write in C++
		 	 * They take an array of WrappedUnionObject
				 * This type is a non-reference-counted version of the standard Object
				 * It acts as an intermediate object between the types that its union can store and an Object
				 * It can be efficiently converted to any type that it stores
				 * It can also be converted to an Object by adding a Location object and classifying it as weak or strong
			 * They are more efficient since you can interpret arguments as a variety of other types for efficiency
			 * Function returns an Object
		 */
		list
		/*
		 * This type means that the object's union value is an array
		 * To be converted to another type, each object must be convertible to the same type
		 * If the types within a list are not all the same or convertible to a common type, use 'o' as type
		 */
	};

	struct Arguments {
	/*
	 * Handles input of arguments into a function
	 * Keyword arguments are unified with positional arguments so no additional members required
	 */
	public:
		size_t min_args;
		//Minimum number of positional arguments number that are named and not optional, raising error if count is less than this
		std::vector<std::function<Intermediary()> > optional_defaults;
		/*
		 * An array of functions which return a value
		 * Since the values are optional, they won't necessarily need to be constructed
		 * As a result, it would be wasteful to construct the objects immediately
		 * A macro (UL_RET(x)) is used to return the exact value entered
		 * The return type of the lambda is `UL::Object`
		 * The object is constructed when the lambda is called using implicit conversion
		 */
		bool is_variadic;
		//Whether the function accepts any number of arguments (all extra arguments are put into an array with a single identifier)
		size_t optional_length;

		std::vector<char> types;
		std::vector<unsigned short> array_depths; //I think that 65535 dimensions in a list is enough :)
		//e.g. "i**" corresponds to 'i' in `types` and 2 in `array_types`
		//e.g. std::vector<std::vector<int> >

		/*
		Arguments(size_t m_a, std::vector<Object> o_d, bool i_v)
			: min_args(m_a), optional_defaults(o_d), is_variadic(i_v) {
			std::cout << "  In Arguments constructor body\n";
				optional_length = optional_defaults.size();
		}
		*/

		/*
		Arguments(size_t min_args, std::vector<std::function<WrappedUnionObject()> optional_defaults, bool is_variadic) {
			std::cout << "  In Arguments constructor body\n";
			this->min_args = min_args;
			this->optional_defaults = optional_defaults;
			this->is_variadic = is_variadic;
			this->optional_length = optional_defaults.size();
		}
		*/

		Arguments(std::string chars, std::vector<std::function<Intermediary()> >) {
			/*
			 * This constructor parses a string, e.g. "iii;dd;o*"
			 * The first part is the required positional arguments - there are 3 integers in the example
			 * The second part is the optional arguments, 2 doubles in this case
			 * The third part is what type the optional arguments are
			 * Each asterisk represents an array of that type
			 * In the 3rd part, using an asterisk means that it's a vector of objects
			 * Note that a 'list' is still a valid Object type
				 * It provides functionality but is slower
				 * Adding a star converts it to a vector container
			 * Available characters:
				 *  i, integer
				 *  d, double
				 *  o, UL::Object
				 *  s, std::string
			 */
			types = std::vector<char>();
			array_depths = std::vector<unsigned short>();
			unsigned char semicolons_count = 0; //No point adding more unnecessary
			is_variadic = false;
			for (size_t i = 0; i < chars.length(); i++) {
				if (chars[i] == ';') {
					if (semicolons_count == 0) { //Minimum arguments
						min_args = i; //Since counting starts at zero
						++semicolons_count;
					} else if (semicolons_count == 1) {
						optional_length = i - min_args - 1;
						++semicolons_count;
					} else { //3
						/*
						 * Single type, storage for a list
						 * If all of the variables are different, write as "o*"
						 * If a * is not present, the character must be 'o'
						 */
						++semicolons_count;
						is_variadic = true;
					}
				} else if (chars[i] == '*') {
					++array_depths.back(); //Increment the array depth of the most recent object
				} else {
					types.push_back(chars[i]);
					array_depths.push_back(0); //Initialise with depth zero
				}
			}

		}

		~Arguments() {

		}
	};

	struct FunctionWrapper {
		Arguments argument_object;
		std::function<void(std::vector<UL::Intermediary&>, UL::Arguments&)> lambda_object;
		FunctionWrapper(Arguments arguments, std::function<void(std::vector<UL::Intermediary&>, UL::Arguments&)>& lambda)
			: argument_object(arguments), lambda_object(lambda) {
			std::cout << "Constructing FunctionWrapper object " << this << "\n";
		}
	};

	typedef union {
			char *string_val; //For string
			double *numerical_val; //For number (pointer to allow for 'big float' refactor later)
			FunctionWrapper *argument_info; //For function
			std::vector<Intermediary> *list_val; //For a list
		} object_union_t;

	typedef struct Intermediary {
		object_union_t union_storage;
		Builtins type;
		bool no_delete_ptr = false;

		Intermediary(const char* string)
			: type(Builtins::string) {
			std::cout << "Constructing string WUO " << this << "\n";
			union_storage.string_val = new char[strlen(string) + 1]; //Allocate correct number of bytes + 1 (null terminator)
			strcpy(union_storage.string_val, string); //Copy `const char*` to `char*`
		}

		Intermediary(double x)
			: type(Builtins::number) {
			std::cout << "Constructing numerical WUO " << this << "(" << x << ")\n";
			union_storage.numerical_val = new double(x);
		}

		Intermediary(FunctionWrapper function_data) //Includes a function and the types of arguments added
			: type(Builtins::function) {
			std::cout << "Constructing function WUO " << this << "\n";
			*union_storage.argument_info = function_data;

		}

		Intermediary(std::initializer_list<Intermediary> beil)
			: type(Builtins::list) {
			std::cout << "Constructing vector WUO " << this << "\n";
			//for(auto it : beil) std::cout << it.union_storage.numerical_val << "\n";
			union_storage.list_val = new std::vector<Intermediary>(); //brace-enclosed initialiser list
			*union_storage.list_val = beil; //Heap-allocated!!!!
		}

		Intermediary(const Intermediary& from)
			: type(from.type) {
			std::cout << "Copying WUO " << &from << " to " << this << "\n";
			//TODO Fix copying of a list
			switch(type) {
				case Builtins::number:
					union_storage.numerical_val = new double(*from.union_storage.numerical_val);
					break;
				case Builtins::string:
					strcpy(union_storage.string_val, from.union_storage.string_val);
					break;
				case Builtins::function:
					union_storage.argument_info = from.union_storage.argument_info;
					break;
				case Builtins::list:
					union_storage.list_val = new std::vector<Intermediary>(*from.union_storage.list_val);

			}
		}

		~Intermediary() {
			if (!no_delete_ptr) {
				switch(type) {
					case Builtins::number:
						delete union_storage.numerical_val;
						break;
					case Builtins::string:
						delete[] union_storage.string_val;
						break;
					case Builtins::function:
						delete union_storage.argument_info;
						break;
					case Builtins::list:
						delete union_storage.list_val;
						break;
				}
			}
			std::cout << "Destructed WUO " << this << "\n";
		}

		void convert(void* target_ptr, char symbol, unsigned short array_depth) {
			/*
			 * Converts a WrappedUnionObject to another object
			 * It is guarunteed that target_ptr can be converted to the target type
			 * E.g. target_ptr may also be an int pointer and therefore can have its value modified to an integer safely
			 */
			std::cout << "Converting " << target_ptr << " -> " << symbol << "\n";
			switch(symbol) {
				case 'i':
					*(int*)target_ptr = (int)*union_storage.numerical_val;
					//Double is automatically truncated when converting to int
					//Explicit conversion added for clarity but not required
					//Copies ptr but stops the ptr from being deleted when object deleted
					no_delete_ptr = true;
					std::cout << "  " << *(int*)target_ptr << "\n";
					break;
				case 'd':
					*(double*)target_ptr = *union_storage.numerical_val;
					no_delete_ptr = true;
					std::cout << "  " << *(double*)target_ptr << "\n";
					break;
				case 'o':
					//(Object)(*target_ptr) =
					break;
				default:
					std::cerr << symbol << " not allowed\n";
			}
		}

	} wrapped_object_union_t;

	std::ostream& operator <<(std::ostream& stream, const Intermediary& object) {
		switch (object.type) {
			case Builtins::number:
				stream << *object.union_storage.numerical_val;
				break;
			case Builtins::string:
				stream << object.union_storage.string_val;
				break;
			case Builtins::function:
				stream << "[Function]";
				break;
			case Builtins::list:
				stream << "{";
				for (auto it = object.union_storage.list_val->begin(); it != object.union_storage.list_val->end(); it++) {
					if (it != object.union_storage.list_val->begin())
						stream << ", ";
					stream << *it;
				}
				stream << "}";
		}
		return stream;
	}

	void bin_type_error(const char* op) {
		throw std::runtime_error(std::string("Could not perform operation ") + op);
	}

	typedef std::vector<Object&> dy_vec_t; //First argument is modified in-place



	struct Location {
		unsigned int reference_count;
		static std::set<Location*> instances;

		Location()
			: reference_count(1) {
			std::cout << "NEWREF " << this << "\n";
			instances.insert(this);
		}
		~Location() {
			std::cout << "DELREF " << this << "\n";
			instances.erase(this);
		}

		void operator ++() {
			reference_count++;
			std::cout << "INCREF " << this << " to " << reference_count <<"\n";
		}

		void operator --() {
			reference_count--;
			std::cout << "DECREF " << this << " to " << reference_count <<"\n";
			/*
			if (reference_count == 0) delete this; //Can I do this?
			 */
		}

		static std::string show_instances() {
			std::stringstream stream;
			stream << "{";
			for (auto it = instances.begin(); it != instances.end(); it++) {
				if (it != instances.begin()) stream << ", ";
				stream << *it << ":" << (**it).reference_count;
			}
			stream << "}";
			return stream.str();
		}
	};
	std::set<Location*> Location::instances = std::set<Location*>(); //Construct set ASAP

	struct Cacher {

	};

	struct Object {
		//std::map<std::string, Object*> values;
		Builtins type; //An object's type cannot be changed - the identifier will be reassigned
		Location* location_reference; //1 or more objects share the same location and increase reference to it
		bool is_weak_reference;
		object_union_t union_storage;

		Object(double x, bool is_weak_reference = false)
			/*
			The integer is the fundamental numeric type
			This is currently a placeholder for a future type, such as `BigFloat`
			It is a built-in type, containing members of its own type and relying on objects which rely on it
			As such, it must have special behaviour to allow this
			Other built-in types may access its `primitive_storage` but user-defined types may only intereact with its interface
			 */
			: type(Builtins::number), location_reference(new Location), is_weak_reference(is_weak_reference) {
			std::cout << "Constructed " << this << "\n";
			union_storage.numerical_val = new double(x);
		}

		Object(std::string string, bool is_weak_reference = false)
			: type(Builtins::string), location_reference(new Location), is_weak_reference(is_weak_reference) {
			std::cout << "Constructed " << this << "\n";
			union_storage.string_val = new char[string.length() + 1]; //Allocate correct number of bytes + 1 (null terminator)
			strcpy(union_storage.string_val, string.c_str()); //Copy `const char*` returned from `string.c_str()` to `char*`
		}

		Object(Builtins type, bool is_weak_reference = false) //Construct and store a string
			/*
			Simple constructor
			This assumes that other information is dealt with elsewhere
			E.g. does not change `union_stores_string_val` depending on value of `type`
			 */
			: type(type), location_reference(new Location), is_weak_reference(is_weak_reference) {
			std::cout << "Constructed " << this << "\n";
		}

		Object(Arguments arguments_data, std::function<Object(std::vector<Intermediary&>, Arguments&)>, bool is_weak_reference = false)
			: type(Builtins::function), location_reference(new Location), is_weak_reference(is_weak_reference) {
			//union_storage.argument_info = &arguments_data;
			//TODO uncomment this
		}

		Object(Intermediary& intermediary, bool is_weak_reference = false)
			: type(intermediary.type), location_reference(new Location), is_weak_reference(is_weak_reference), union_storage(intermediary.union_storage) {
		}

		Object(const Object& from, bool force_weak = false)
		/*
		The copy constructor creates a new object but also increments the references to what it copies.
		 */
			: type(from.type), location_reference(from.location_reference), is_weak_reference(force_weak || from.is_weak_reference) {
			std::cout << "Copied " << this << "\n";
			if (type == Builtins::number) //If values are equal, 0 is returned
				union_storage.numerical_val = from.union_storage.numerical_val;
				//Exactly the same object is stored, since only the pointer is copied
			else if (type == Builtins::string)
				union_storage.string_val = from.union_storage.string_val;
			if (!is_weak_reference)
				++*location_reference;
		}

		~Object() {
			std::cout << "Deleted " << this << "\n";
			if (!is_weak_reference) {
				--*location_reference;
				if (location_reference->reference_count == 0) {
					delete location_reference;
				}
				if (type == Builtins::number)
					delete union_storage.numerical_val;
				else if (type == Builtins::string)
					delete union_storage.string_val;
				switch (type) {
					case Builtins::number:
						delete union_storage.numerical_val;
						break;
					case Builtins::string:
						delete[] union_storage.string_val;
						break;
					case Builtins::function:
						delete union_storage.argument_info;
						break;
					default:
						std::cerr << "Could not find type of object " << this << "\n";
				}
			}
		}

		Object operator *(const Object& arg2) {
			/*
			This first creates a copy but forces it to be a weak reference since the data will be modified
			After the values have been modified, it then finds the appropriate location
			It then becomes a strong reference to that location
			(otherwise its deletion would not decrement/delete the location set)
			Finally, it returns the new object
			 */
			Object result(*this, true);
			if (type == Builtins::number) {
				*result.union_storage.numerical_val *= *arg2.union_storage.numerical_val;
				result.set_location();
				//Guaruntee that it stores a numerical value since is integer type
			} else
				bin_type_error("mul");
			return result;
		}

		void set_location() {
			//TODO: cache certain integer range
			location_reference = new Location;
			is_weak_reference = false; //Become strong reference to new reference location
		}
	};

	std::ostream& operator <<(std::ostream& stream, const Object& object) {
		stream <<
				"<" <<
				static_cast<typename std::underlying_type<Builtins>::type>(object.type) <<
				":" <<
				object.location_reference;
		if (object.type == Builtins::number)
			stream << ":" << *object.union_storage.numerical_val;
		else if (object.type == Builtins::string)
			stream << ":\"" << object.union_storage.string_val << "\"";
		return stream << ">";
	}

	/*
	std::map<std::string, std::map<std::string, std::function<void(dy_vec_t)> > > data_types = {

	};
	 */

	struct Exception {
		/*
		The Exception class is intended to be a base class for a variety of different exceptions
		When called, the current scope should be exited and all variables within decref'd
		Each scope is deleted and each identifier in it is decref'd and deleted if necessary
		This continues until the current scope exits into a 'try{}catch(){}...'
		If none are met and the number of scopes reaches zero, the program ends in a crash
		 */
		const char* message;
		Exception(const char* message)
			: message(message) {
		}

		void Raise() {
			std::cerr << message << "\n";
			//TODO make error without crashing the interpreter
		}
	};

	//bool func_assign_args(std::vector<Object*>& arguments_input, Arguments& arguments_data, std::vector<void*>& variables, std::vector<Object*>* variadic_var=nullptr) {
		/*
		 * UL::Object is cumbersome to use compared to a normal C++ object or primitive type
		 * The arguments entered can be any type that can be converted from a UL::Object
		 *
		 * Each variable is assigned to each argument entered
		 * `arguments_data` contains information about the structure of the arguments
		 * `arguments_input.size()` must be at least `arguments_data.min_args`, which is the number of positional arguments entered in the function definition
		 * `arguments_input.size()` must have a maximum of `arguments_data.min_args + arguments_data.optional_length` unless the function is variadic
		 * If the function is variadic, there is no limit to `arguments_input.size()` except for the value of `size_t` (imposed by C++ implementation & architecture)
		 * `variables.size()` must have a length of at least `arguments_data.min_args` and at most `arguments_data.min_args + arguments_data.optional_length`
		 * `variadic_var` stores the extra arguments - all arguments beyond the required and optional arguments are put into an array here.
		 */

		/*
		if (variables.size() < arguments_data.min_args || (!arguments_data.is_variadic && variables.size() > arguments_data.min_args + arguments_data.optional_length))
			return false;
		if (arguments_input.size() != arguments_data.min_args + arguments_data.optional_defaults.size())
			return false;
		if ((variadic_var != nullptr) == arguments_data.is_variadic) //If a pointer has been given for extra arguments, it must be a variadic function and vice versa
			return false; //equivalent to `variadic_var != nulltptr XNOR arguments_data.is_variadic`
		size_t i = 0;
		for (; i < arguments_data.min_args; i++) variables[i] = arguments_input[i]; //IMPORTANT: This copies a pointer across, not an object
		for (; i < arguments_data.optional_defaults.size(); i++) *variables[i] = arguments_data.optional_defaults[i - arguments_data.min_args];
		if (arguments_data.is_variadic)
			for (; i < arguments_input.size(); i++) variadic_var->push_back(arguments_input[i]);

		return true;
		*/
	//}

	int parse_assign(std::vector<Intermediary*> arguments_input, std::string parse_this, std::vector<std::function<Intermediary()> > default_options, std::vector<void*> variables, void* variadic_var=nullptr) {
		Arguments arguments_data(parse_this, default_options);
		//std::cout << (variadic_var != nullptr) << "," << arguments_data.is_variadic << "\n";
		if (variables.size() < arguments_data.min_args || (!arguments_data.is_variadic && variables.size() > arguments_data.min_args + arguments_data.optional_length))
			return false;
		if ((!arguments_data.is_variadic) && arguments_input.size() > arguments_data.min_args + arguments_data.optional_length) {
			//std::cout << arguments_input.size() << "," << arguments_data.min_args << ", " << arguments_data.optional_length << "\n";
			return false;
		}
		if ((!variadic_var) == arguments_data.is_variadic) //If a pointer has been given for extra arguments, it must be a variadic function and vice versa
			return false; //equivalent to `(variadic_var != nulltptr) XNOR arguments_data.is_variadic`
		size_t i = 0;
		for (; i < arguments_data.min_args; i++) arguments_input[i]->convert(variables[i], arguments_data.types[i],  arguments_data.array_depths[i]); //Required arguments
		if (arguments_input.size() < arguments_data.min_args + arguments_data.optional_length) {
			for (; i < arguments_input.size(); i++)
				arguments_input[i]->convert(variables[i], arguments_data.types[i], arguments_data.array_depths[i]);
			//std::cout << "Made it here: " << i << "\n";
			for (; i < arguments_data.min_args + arguments_data.optional_length; i++) {
				//std::cout << (i - arguments_data.min_args) << "\n";
				default_options[i - arguments_data.min_args]().convert(variables[i], arguments_data.types[i],  arguments_data.array_depths[i]);
			}
		} else {
			for (; i < arguments_data.min_args + arguments_data.optional_length; i++)
				arguments_input[i]->convert(variables[i], arguments_data.types[i], arguments_data.array_depths[i]);
		}
		return true;
	}

}
int main() {
	std::cout << __cplusplus << "\n";
	SEP;
	/*
	UL::Object ten(10); //NEWREF
	SEP;
	UL::Object also_ten = ten; //INCREF
	SEP;
	UL::Object three(3); //NEWREF
	SEP;
	std::cout << ten << ", " << also_ten << ", " << three << "\n";
	SEP;
	//UL::Object thirty = ten * three;
	//SEP;
	std::cout << ten * three << "\n";
	SEP;
	std::cout << UL::Location::show_instances() << "\n";
	SEP;
	*/

	//UL::Arguments arguments = {3, {5, 6, 7, 8}, false};
	//std::cout << arguments.min_args << "\n";
	//std::cout << arguments.optional_length << "\n";
	//std::cout << arguments.is_variadic << "\n";

	/*
	UL::Object({3, {5,6}, false}, [](std::vector<UL::Object&> arguments_input, UL::Arguments& arguments_data){
		UL::Object a, b, c, d, e;
		if (!UL::func_assign_args(arguments_input, arguments_data, {a, b, c, d, e}))
			std::cerr << "hOw CoUlD tHiS hApPeN\n";
	})
	*/;

	/*
	UL::Object func({3, {UL_RET(5), UL_RET(6)}, true}, [](std::vector<UL::Object>) {
		double u, v;
		double *w;
		int x, y, z;
		if(!UL::func_assign_args(arguments_input, arguments_data, {&a, &b, &c, &d, &e}, extra))
			return NULL;

		})
	  */

	/*
	//{3, {5, 6}, true}
	//{"iii;dd;O*"}
	UL::Object func({3, {5, 6}, true}, [](std::vector<UL::WrappedUnionObject&> arguments_input, UL::Arguments& arguments_data) {
		int a, b, c;
		double d, e, mean;
		if(!UL::func_assign_args(arguments_input, arguments_data, {&a, &b, &c, &d, &e})) return NULL;
	});
	*/
	/*
	UL::Arguments args("iii;dd;", {UL_RET(5), UL_RET(6)});
	std::cout << args.min_args << ", " << args.optional_length << "\n";
	int a, b, c;
	double d, e, mean;
	UL::Intermediary w = 99, x = 11.5, y = 3.5, z = 8;
	std::cout << UL::parse_assign({&w, &x, &y, &z}, "iii;dd;", {UL_RET(5), UL_RET(6)}, {&a, &b, &c, &d, &e}, nullptr) << "\n";
	mean = (d + e) / 2 + a + b + c;
	std::cout << mean << "\n";
	*/
	{
		//UL::Intermediary object({1,{2, 3, {4, 5}, 6, 7}, 8});
		UL::Intermediary function(UL::FunctionWrapper({"iii;dd;", {UL_RET(5), UL_RET(6)}}, UL_LMBD{}));
		SEP;
		std::cout << function << "\n";
		SEP;
	}
	SEP;
	//std::cout << "SUCCESS :))))))))))))))))))))))))\n";
	return 0;
}