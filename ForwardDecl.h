#ifndef OBJECT_H
#define OBJECT_H

namespace UL {
    enum class Builtins {
        null=0,
		number,
		/*
		 * The default number type stores an int
		 * TODO Make it store big float
		 * Each integer or float literal is converted to this type
		 */
		string,
		/*
         * Stores a sequence of (wide) characters
		 * The value is not constant and all operations are in-place
		 */
		cpp_function,
		/*
		 * Does not have an associated union type
		 * While it has a 'call' method, it is also directly callable
		 * (otherwise there would be infinite recursion)
		 * It doesn't need to know argument type but it needs to know number of arguments
		 * Takes a list of argument names and an optional name to store all extra arguments in list form
		 * TODO Add keyword arguments (not separate syntax)
		 *
		 * There are 2 types of functions, depending on the context
		 * Functions that you write in Unnamed Language
		 	 * They take an array of Object
		 	 * The code within is generated by the UL interpreter
		 	 * They are less efficient since the interpreter doesn't know what you'll do with the variables
		 	 * Likely less human-readable
		 * Functions that I write in C++
		 	 * They take an array of WrappedUnionObject
				 * This type is a non-reference-counted version of the standard Object
				 * It acts as an intermediate object between the types that its union can store and an Object
				 * It can be efficiently converted to any type that it stores
				 * It can also be converted to an Object by adding a Location object and classifying it as weak or strong
			 * They are more efficient since you can interpret arguments as a variety of other types for efficiency
			 * Function returns an Object
		 */
        bytecode_function,

		list
		/*
		 * This type means that the object's union value is an array
		 * To be converted to another type, each object must be convertible to the same type
		 * If the types within a list are not all the same or convertible to a common type, use 'o' as type
		 */
	};

    struct Object;

    enum class Builtins;
    struct ByteCodeFunction;
    struct CppFunction;
    struct Location;

    union ObjectUnion {
        std::string *string_val; //std::string pointer
        double *numerical_val; //pointer to double
        CppFunction *function_val; //pointer to a C++ function
        ByteCodeFunction *bytecode_val; //pointer to a bytecode function, which stores a start val & number of lines
        std::vector<Object> *list_val; //pointer to a vector of objects
    };

    struct Object {
        ObjectUnion union_val;
        Builtins type;
        bool is_weak;
        Location *reference_location;
        Object(std::nullptr_t, bool=false);
        Object(double, bool=false);
        Object (const char*, bool=false);
        Object(CppFunction*, bool=false);
        Object(ByteCodeFunction*, bool=false);
        Object(std::vector<Object>*, bool=false);
        Object(std::vector<Object>, bool=false);
        Object(const Object*, bool=false);
        ~Object();
        operator int() const;
        operator std::string () const;
        Object* operator ()(std::vector<Object*> inputs);
        //operator double();
        Object operator *(const Object&);
        void push_back(Object* object);
    };
}

std::ostream& operator <<(std::ostream& stream, const UL::Object& object);
std::ostream& operator <<(std::ostream&, const UL::Builtins) ;

#endif